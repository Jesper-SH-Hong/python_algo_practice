# 최소힙:  완전이진트리.  root가 최소값. <-> 최대힙
# 간선: edge, 줄기


# 트리의 종류: 이진트리 -> 완전 이진트리 -> 포화 이진트리

# 이진(bin)트리: 그냥 edge가 2개씩인 트리(leaf, children 개판ㅋㅋ)
# 완전(complete)이진트리: 이진트리 && 마지막 레벨 외 노드는 다 차있음.(children은 별개) + 마지막 레벨 노드(leaf)는 왼쪽부터 어느정도 채워져있음.
# perfect binary tree - 완전 && 마지막 레벨 외의 모든 노드는 두개의 children(당연히 마지막 레벨도 꽉 참)

# 우선순위 높은 것을 뺴내고 싶을 떄 유용.
# 이진트리: 부모노드가 항상 자식보다 우선순위 높다. 라는 원칙
# 기존 리스트로 모든 원소 sorting하는 것보다 효율적.

# 그렇게 root를 pop했을 시,

# 리스트로 구현함.


# 리스트로 받은 자료들을 어떻게 최소힙(root가 제일 작게) 구성할래?

l = [5, 3, 2, 1, 4, 6, 7]


# 힙 자리표
#      1
#   2     3
#  4  5  6  7
# 빈 heap이니까 가장 먼저 root(1)노드에 "5"가 들어감. 왼쪽부터 채워나감. 레벨부터 채움
# 3이 들어오면 (2)자리에 들가서 부모("5")랑 비교함.  최소힙이니 3이 root로 가야. swap
# 2가 들어오면 3 자리에 2가 입력되고, 부모("3")랑 비교함. 2가 작으니 루트로.

#    2
#  5    3

# 이제 1이 들어오면 부모(2포지션, 현재 "5")랑 비교, 작으니 swap
# 2포지션에 와서 다시 부모(root)와 비교, 작으니 swap

#      2                2               "1"
#   5     3    ->   "1"    3          2    3
#  "1"            5               5

# 그래서 이렇게 heap에 push하면 레벨순으로 넣고, 부모순으로 비교하면서 올라갈 수 있으면 up heap함.
# heap pop 하면 루트값이 나옴 (최소힙이니 최소값 1이 나올것)

#    "1"              " "                "7"
#   2    3    ->     2    3       ->   2     3
# 5  4  6   7      5  4  6  "7"      5  4  6

# pop으로 뽑히고 나면 마지막 레벨 가장 오른쪽 leaf를 루트에 올리고 down heap함(자식과 비교하면서 자긴 내려가고 다음 최소값을 올림)

#     "7"             2             2
#   2     3   ->  "7"    3   ->  4      3
#  5  4  6       5   4  6      5   "7"    6      #요래 다시 최소힙의 완성.   # 이 과정 면접에 물어봄ㅋㅋ


# 만약 기존 heap에 푸시하면 마지막 노드의 다음 노드에 붙음.


import sys
import heapq as hq

sys.stdin = open('input.txt', 'r')

a = []  # 파이썬에서 heapq하려면 리스트 필요. 거기에 푸시, 팝.  힙푸시,팝이란 메서드를 쓰면 이 리스트가 힙처럼 작동함

while True:
    n = int(input())
    if n == -1:  # 문제상에서 -1을 인자로 받으면 종료하래.
        break
    if n == 0:  # 힙에서 제일 루트에 있는 걸 print하시오
        if len(a) == 0:  # 빈 힙이다.
            print(-1)
        else:
            print(hq.heappop(a))  # root node를 팝

    else:
        hq.heappush(a, n)  # a란 리스트에 n을 푸시해라. 트리형태. 최소힙의 형태로 넣어라. hq.heappush

#       <1> <-------> <2>  ------>  <5>
#        |           /  |\         /|
#        |         /    |        /
#        |       /      |      /
#        |     /        |    /
#       \|  |/          |  /
#       <3> --------> <4>

# 1 2 3 4 5
# 1 2 5
# 1 3 4 2 5
# 1 3 4 5
# 1 4 2 5
# 1 4 5
# 위는 1->5로 가는 경로.  총 가지수가 몇가지인지 구하라.

# 상태트리 사용, 체커로 이미 방문한 곳 재방문 막아야.

# D(노드)

#                 D(1)
#        1/    2|    3|    \4      \5      1에서 모든 노드들 중 갈 수 있는 노드로만 확장될 것.
#            D(2)   D(3)   D(4)...            타고 온 가지 번호를 넘겨주는 거임.
#         1/2||3\4\5           -for문은 그대로 1~5 돌아. 앞서 배운 인접행렬로 접근가능한 지 체크. 근데 이미 방문한(체크된 곳) 제거.
#             |    \
#            D(3)    D(5)..step3
#         1/2||3\4  \5...step2
#         x  xx D(4)           -방문한 곳도 빼야지.
#              1/2||3\4\5
#              x x x x  D(5)   드디어 종착. 여기서 카운팅. D(V)가 if v== n이더라..! 오키 cnt+=1
#                        step1        근데 이제 그럼 다시 노드 4로 돌아가야 하니 visited에서 "5 체크한 거 풀어줘야 할 것."

def DFS(v):
    global cnt
    if v == n:
        cnt= cnt + 1   #cnt = cnt +1임. 즉 = 이다보니 cnt를 로컬 변수로 인식해서 에러남. global cnt하셈
        for x in path:
            print(x, end=' ')
        print()
    else:
        for i in range(1, n + 1):  # 일단 노드수만큼 뻗어야 함!
            if g[v][i] == 1 and ch[i] == 0:  # g[v]는 현재 도착/위치한 노드임  && 방문기록 없음
                ch[i]=1
                path.append(i)
                DFS(i)
                path.pop()
                ch[i]=0


if __name__ == "__main__":
    n = 5
    m = 9
    edges = [[1, 2], [1, 3], [1, 4],
             [2, 1], [2, 3], [2, 5],
             [3, 4],
             [4, 2], [4, 5]]

    g = [[0] * (n + 1) for _ in range(n + 1)]
    ch = [0] * (n + 1)

    for i in range(m):
        a, b = edges[i][0], edges[i][1]
        g[a][b] = 1

    print(g)
    cnt = 0
    path=[]
    path.append(1)
    ch[1] = 1
    DFS(1)
    print(cnt)

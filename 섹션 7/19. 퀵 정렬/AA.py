# 이 또한 divde and conquer 병합정렬처럼 분할/정복인데

# 병합 정렬이 후위순회 방식(왼쪽 자식, 오른쪽 자식 작업이 끝나면 와서 본연의 일(병합)
# 얘는 전위순회 방식임
# 왼쪽/오른쪽 자식으로 분화되기 전에 자기 일(partition)을 먼저 함. 즉 중심값(pivot) 중심으로 작은 건 왼쪽, 큰 건 오른쪽에 모이게 함.
# 그 분할한 기준에 따라 왼/오른쪽 자식으로 호출이 일어남.



# 그림으로 하자면

#idx     0   1   2   3   4   5   6   7   8    9
# arr = [45, 21, 23, 36, 15, 67, 11, 60, 20, 33]

# 매개변수는 lt, rt. 왼쪽 끝과 오른쪽 끝 지점. idx lt~rt까지 정렬하겠다.

# Q(0,9)   0~9 인덱스를 정렬해라.
#
# 1)파티션(개괄)
# pivot은 맨왼쪽, 맨 뒤, 가운데 등 방법은 다양히 연구중임. 성능이 달라짐. 젤 흔한 방식은 맨 뒷값을 고름.
# pivot = arr[rt]

#    21 23 15 11 20 / 33 / 45 36 67 60                  함수바디~~~
#    lt           rt                                     Q(     )
#                          lt        rt                  q(     )


#처리 방법
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [45, 21, 23, 36, 15, 67, 11, 60, 20, 33]
#        |
#       pos

#pivot = arr[9] = 33

# pos는 0번 idx를 가리키고 for문이 정렬하고픈 영역의 왼쪽끝(lt)부터 rt-1(8)까지  죽 훑음.  rt놈을 피봇으로 쓰니까

# 첫째, i = 0
# arr[0] > pivot이니까 걍 i는 지나감


# i = 1
#            i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [45, 21, 23, 36, 15, 67, 11, 60, 20, 33]
#         |
#        pos

# 21<33이니까
# arr[i]< pivot임. 즉 뭔가 해야 함. 이 떄 pos와 swap함
# arr[pos] <-> arr[i]
# 교환 후 pos는 1 증가함.(우측 이동)

#            i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 45, 23, 36, 15, 67, 11, 60, 20, 33]
#            |
#           pos




# i = 2
#                i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 45, 23, 36, 15, 67, 11, 60, 20, 33]
#            |
#           pos

# 23 < 33이니.. 또 arr[pos] <-> arr[i], pos++




# i = 3
#                    i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 23, 45, 36, 15, 67, 11, 60, 20, 33]
#                |
#               pos

# 근데 36 > 33이니 걍 i만 커짐



# i = 4
#                        i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 23, 45, 36, 15, 67, 11, 60, 20, 33]
#                |
#               pos

# arr[i]  < pivot 이니    swap, pos ++

# i = 5
#                            i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 23, 15, 36, 45, 67, 11, 60, 20, 33]
#                    |
#                   pos

# 67 > pivot   i 스킵


# i = 6
#                                i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 23, 15, 36, 45, 67, 11, 60, 20, 33]
#                    |
#                   pos

#   11 < 33이네.. swap,    pos++ 하자.


#i = 7
#                                    i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 23, 15, 11, 45, 67, 36, 60, 20, 33]
#                         |
#                        pos

#i = 8
#                                        i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 23, 15, 11, 45, 67, 36, 60, 20, 33]
#                         |
#                        pos
# 20 < 33   swap..  pos++


# i가 8까지 다 돌고 9 가기 전 최종 상태       i
#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 23, 15, 11, 20, 67, 36, 60, 45, 33]
#                            |
#                           pos


# 이제 pivot과 pos를 swap함.

#idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 23, 15, 11, 20, 33, 36, 60, 45, 67]                 # 정렬은 아니지만 partition은 끝!
#                            |
#                           pos

#이로써 pivot이었떤 값은 자기 자리를 찾은 거임 arr[5]. 지 기준으로 앞 뒤에 다 작/큰 거 몰아놨으니


# def Qsort(lt, rt):
#     if lt<rt:      #즉 두조각->1조각 될 때 끝낸다.

        #partition
        #q(lt, pos-1)  # 0~4    새 피봇 arr[4]
        #q(pos+1, rt)    #6~9   새 피봇 arr[9]




# idx     0   1   2   3   4   5   6   7   8    9
# arr = [21, 23, 15, 11, 20, 33, 36, 60, 45, 67*]            Q(0,9)의 결과
#                                                           /     \
# arr = [15, 11, 20, 23, 21*, 33, 36, 60, 45, 67]       Q(0,4)
#                                                       /   \
# arr = [11, 15, 20*, 23, 21, 33, 36, 60, 45, 67]    Q(0,1) ....q(3,4)
#                                                     /   \
#                                                 Q(0,0)  q(1,1)   -> lt= rt.  lt < rt 아니라 걸러지고 끝나버림.


def Qsort(lt, rt):
    if lt < rt:
        pos = lt
        pivot = arr[rt]

        for i in range(lt, rt-1):
            if arr[i] <= pivot:
                arr[i], arr[pos] = arr[pos], arr[i]
                pos += 1

        arr[rt], arr[pos] = arr[pos], arr[rt]         # 파티션 종료

        Qsort(lt, pos-1)
        Qsort(pos+1, rt)


if __name__ == "__main__":
    arr = [45, 21, 23, 36, 15, 67, 11, 60, 20, 33]
    print("Before sorting: ", end=' ')
    print(arr)
    Qsort(0,9)
    print("After sorting: ", end=' ')
    print(arr)


#1개까지 분할해 들어가다 보면 정렬이 끝나있음ㅋㅋ
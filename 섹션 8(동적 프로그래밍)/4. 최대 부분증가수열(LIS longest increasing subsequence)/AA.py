# N개의 자연수 수열에서 가장 긴 증가 수열을 만들어라.(순서 유지)

# 2 7 5 8 6 4 7 12 3 인 경우 정답은
# 2 5 6 7 12

# idx  1  2  3  4  5  6  7  8    0번은 버릴겨ㅋㅋㅋ
arr = [5, 3, 7, 8, 6, 2, 9, 4]
n = len(arr)

# 어떻게 풀지?
# 간단한 문제로 최소화 했다가 확장 해보자(bottm up)

# [5, 3,  7,    8,     6, 2, 9, 4]
#  5     3 7   3 7 8  3 6
#  3     5 7   5 7 8  5 6
#              3 8
#              7 8


# 1) 첫항이자 마지막 항이 곧 5임. -> 5

# 2) 증가수열의 마지막 항이 3임. -> 3 (앞에 5는 못 오니)

# 3) 7이 내가 만들 중가수열의 마지막 항이면? 그 바로 앞 항으로는 뭐가 가능함?
#    3이 가능함
#    오 그럼 3이 마지막일 때 만들 수 있던 증가수열은? '3' 딱 하나였음ㅋㅋ '3 7'
#    근데 5까지 전진했을 때도 '5'만 있는 5 7 가능함


# 4)  8이 마지막 항인 증가수열을 만들고픔. 그럼 앞 5,3,7만 보면 됨.
# 1. 바로 앞이 7   = [3 7],  [5 7] -> 3,7,8 5,7,8
# 2. 바로 앞이 3   = 3  -> 3,8
# 3. 바로 앞이 5   = 5   -> 5,8

# 이상 4가지

# 이런 식으로 앞에 거에 붙어서 계속 ㅋㅋㅋㅋ

# 5) 6은.. 바로 앞에 3, 5만 가능..


# ...   9는 앞서 본 모든 거를 앞에 붙이면 됨..


# idx  1  2  3  4  5  6  7  8    0번은 버릴겨ㅋㅋㅋ
arr = [5, 3, 7, 8, 6, 2, 9, 4]

# dy[i] = arr[i]가 마지막 항일 떄 만들 수 있는 증가수열 중 가장 "길이가 긴 놈"
# dy[7] = 9가 마지막이면서 가장 긴 수열의 길이

# dy[1] = 1  #지 혼자니까 ㅋㅋ
# dy[2] = 1     #지 앞에 for문 돌면서 확인함. 3보다 작으면서 길이가 최대가 되는 놈의 길이
#
# dy[3] = 2 #dy[3]이나 [5]나 1이니까 7 붙이면 2
#
# dy[4] = 3   #8 입장에서는 가장 긴 수열인 7 뒤에 들러붙는 게 가장 길어질 것.

# ...
# 마지막 항 dy[n]을 출력하면 안됨. 마지막 항이 정답이 아님! dy[8] = 2밖에 안됨ㅋㅋㅋ


n = 8
arr = [5, 3, 7, 8, 6, 2, 9, 4]
arr.insert(0, 0)
dy = [0] * (n + 1)
dy[1] = 1
res = 0

for i in range(2, n+1):
    maxx = 0
    for j in range(i-1, 0, -1):  #1까지 내려가게 돎.
        if arr[j] < arr[i] and dy[]j > maxx:  # i보단 앞놈인데 가장 가깝게 큰 놈
            maxx = dy[j]   #arr[j]의 값이 마지막 항인 증가수열의 최대길이.

    dy[i] = maxx + 1   #오키 길이 덧대기
    if dy[i] > res:
        res = dy[i]

print(res)
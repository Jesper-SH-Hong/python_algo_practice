# 동적 프로그래밍
# 크고 복잡한 문제.. 한 번에 풀어내기보단
# 이 문제가 물어보는 질문의 속성..은 유지하면서 문제 크기를 아주 작은 단위로, 우리가 직관적으로 답을 바로 알 수 있는
# 아주 작은 단위의 문제 크기로 바꿈.

# 즉 물어본느 내용 동일, 크기만 작게.

# 그렇게 나온 답을 어딘가에 기록(2차원 배열이나 등등, 메모이제이션)
# 그걸 다음 약간 더 큰 문제로 확장해서 풀이 시, 첫 답을 활용. 점화식 같이 ㅋㅋ

# 요약: 점화식
# ex.. 사이즈:  1 2 4 8 ...> 찾는 문제: bottm-up적 다이내믹 프로그래밍




#네트워크 선을 자르려 한다.
#총 4m를 오직 1m,2m짜리 전선으로 자르려 한다
#1 1 1 1
#1 1 2
#1 2 1
#2 1 1
#2 2

#요래 5가지

#7m면 21가지가 나옴. 50m, 100m도 다이내믹으로 거뜬함.

#dy라는 배열을 만들고, 총길이가 idx인 네트워크 선을 1/2m로 나누는 방법, 즉 해를 넣음.

#전선   0   1   2   3   4   5   6   7
#idx       1   2   3   4   5   6   7
#dy        1   2                         -여기까진 직관적으로 알수 있음

# 총 3m |---|---|---|
#1)              자르다 보면 맨 마지막 토막이 1인 경우
#       |---|---| 그럼 앞에 남은 2m 처리법은 이미 구했지 dy[2]에.
#          1+1
#           2     즉 dy[2]만들던 이 2가지 방법에 마지막에 1m 토막 추가하는 방법 2가지


#2)    |---|---|---|
#           마지막 토막이 2m
#      |---|               그럼 당근 1 + 2라 1가지..


#즉 d[3] = d[1]+d[2]가 되버림


#     |---|---|---|---|
#                  꼬다리가 1인 경우 = d[3]
#              꼬다리가 2인 경우 = d[2]

#즉 f(n) = f(n-1) + f(n-2)



n = 7  #7m

dy = [0]*(n+1)   #1차원 배열/ 테이블
dy[1]=1
dy[2]=2

# if n ==0 or n==1 or n== 2: return n  .. 릿코드 문제용
for i in range(3, n+1):
    dy[i]=dy[i-1] + dy[i-2]

print(dy[n])